<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circular Linked List </title>
    <style>
        /* --- General Styling and Layout --- */
        body {
            font-family: 'Consolas', monospace;
            background-color: #f8f9fa; /* Light background */
            color: #212529; /* Dark text */
            margin: 0;
            padding: 25px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            width: 95%;
            max-width: 1100px;
        }

        h1 {
            color: #17a2b8; /* Cyan Blue */
            text-align: center;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 10px;
            margin-top: 0;
            font-size: 2em;
        }

        /* --- Description Box Styling --- */
        .description-box {
            background-color: #e6f7ff; 
            border-left: 5px solid #17a2b8; 
            padding: 10px 15px;
            margin-bottom: 20px;
            border-radius: 6px;
        }
        .description-box h5 {
            color: #17a2b8;
            margin-top: 0;
            margin-bottom: 5px;
        }
        .description-box ul {
            font-size: 0.9em;
            list-style: none;
            padding-left: 0;
        }

        /* --- Task & Feedback --- */
        #taskDisplay {
            font-size: 1.3em;
            font-weight: bold;
            padding: 15px;
            border-radius: 6px;
            background-color: #ffc107; /* Yellow background for task prominence */
            color: #333;
            text-align: center;
            margin-bottom: 25px;
        }

        #feedback {
            min-height: 40px;
            padding: 10px;
            margin-top: 20px;
            border-radius: 6px;
            text-align: center;
            font-size: 1em;
            transition: all 0.3s ease;
        }
        
        .feedback-success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .feedback-error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6fb; }
        .feedback-info { background-color: #e9ecef; color: #333; border: 1px solid #ced4da; }

        /* --- Circular Linked List Visualization --- */
        #linkedListVisualization {
            min-height: 150px; /* Taller visualization to show circle */
            margin: 30px auto;
            padding: 20px 10px;
            display: flex;
            align-items: flex-start; /* Start from the top */
            justify-content: center;
            flex-wrap: wrap; 
            position: relative;
            width: 100%;
            border: 1px solid #ced4da;
            border-radius: 8px;
            background-color: #ffffff; 
        }

        .node-wrapper {
            position: relative;
            display: flex;
            align-items: center;
            margin: 5px; 
        }

        .cll-node {
            background-color: #f0f8ff; 
            border: 2px solid #007bff; 
            border-radius: 6px;
            padding: 8px 12px;
            display: flex;
            flex-direction: column; 
            box-shadow: 0 2px 8px rgba(0, 123, 255, 0.2);
            min-width: 60px; 
            color: #212529;
            font-weight: 500;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        .cll-node:hover {
            transform: scale(1.05);
        }

        .node-data {
            font-weight: bold;
            font-size: 1.2em;
        }

        .node-pointer-text {
            font-size: 0.7em;
            color: #6c757d;
        }
        
        .cll-node.head-node { border-color: #28a745; box-shadow: 0 0 10px rgba(40, 167, 69, 0.5); }
        .cll-node.highlight-target { background-color: #dc3545; color: white; border-color: #a71d2a; } /* Target for Split (wrong click) */
        .cll-node.highlight-found { background-color: #17a2b8; color: white; border-color: #0d8b9e; } /* Found Split Node */


        .arrow-line {
            width: 30px;
            height: 2px;
            background-color: #007bff;
            position: relative;
            margin-left: 5px;
            margin-right: 5px;
        }
        .arrow-line::after {
            content: '';
            position: absolute;
            right: 0;
            top: -4px;
            border-top: 5px solid transparent;
            border-bottom: 5px solid transparent;
            border-left: 8px solid #007bff;
        }

        .pointer-label {
            position: absolute;
            font-weight: bold;
            font-size: 0.9em;
            color: #28a745;
            z-index: 2;
        }
        #tailPointerLabel { color: #dc3545; }

        /* --- Controls Structure --- */
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            padding: 20px 0;
        }
        .control-section {
            background-color: #f1f1f1; 
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #ced4da;
            text-align: center;
        }
        .control-section h4 {
            color: #007bff;
            margin-top: 0;
            padding-bottom: 5px;
        }

        .input-group { margin-bottom: 10px; }
        .input-group label { display: block; margin-bottom: 5px; color: #555; }
        .input-group input, .input-group select {
            width: calc(100% - 24px);
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ced4da;
            background-color: white;
            color: #212529;
            text-align: center;
        }

        .action-button-row { margin-top: 10px; }
        #startBtn { background-color: #28a745; color: white; }
        #insertBtn { background-color: #007bff; color: white; }
        #splitBtn { background-color: #17a2b8; color: white; }
        #checkBtn { background-color: #ffc107; color: #333; }
        
        button:disabled { background-color: #cccccc; color: #666; cursor: default; }
        
    </style>
</head>
<body>
    <div class="container">
        <h1>Circular Linked List </h1>
        
        <div class="description-box">
            <h5>Circular Linked List </h5>
            <ul>
                <li>A Circular Linked List is a list where the NEXT pointer of the last node points back to the first node HEAD, forming a circle. There is no NULL end.</li>
                <li>The boundary condition for traversal is: current dot next equals HEAD.</li>
                <li>Insertion at the HEAD is often optimized by maintaining a TAIL pointer.</li>
            </ul>
        </div>

        <div id="taskDisplay">Click 'Start Task' to begin!</div>

        <div id="linkedListVisualization">
            <span id="headPointerLabel" class="pointer-label">HEAD</span>
            <span id="tailPointerLabel" class="pointer-label" style="right:10px; left:auto;">TAIL</span>
        </div>

        <div id="feedback" class="feedback-info">
            Instructions: Get ready to perform list operations.
        </div>
        
        <div class="controls-grid">
            
            <div class="control-section">
                <h4>1. OPTIMIZED INSERTION</h4>
                <p style="font-size:0.85em; color:#555;">(Use TAIL pointer to insert at HEAD)</p>
                <div class="input-group">
                    <label for="insertValue">Value to Insert:</label>
                    <input type="number" id="insertValue" placeholder="e.g., 25" disabled>
                </div>
                <div class="action-button-row">
                    <button onclick="handleInsertHeadAttempt()" id="insertBtn" disabled>Execute INSERT at HEAD</button>
                </div>
            </div>

            <div class="control-section">
                <h4>2. BOUNDARY CHECK</h4>
                <p style="font-size:0.85em; color:#555;">(Find the node before the split point N/2)</p>
                <div class="input-group">
                    <label for="splitTarget">List Length (N) is: <span id="listLengthDisplay"></span></label>
                    <label>Target Node Index (N/2): <span id="splitIndexDisplay"></span></label>
                </div>
                <div class="action-button-row">
                    <button onclick="toggleNodeClickMode('split')" id="splitBtn" disabled>Select Node BEFORE Split</button>
                </div>
            </div>

             <div class="control-section">
                <h4>3. TRAVERSAL CHECK</h4>
                <p style="font-size:0.85em; color:#555;">(Count steps until returning to HEAD)</p>
                <div class="input-group">
                    <label for="traversalCount">How many steps (nodes) to reach HEAD?</label>
                    <input type="number" id="traversalCount" placeholder="Enter count"> </div>
                <div class="action-button-row">
                    <button onclick="handleTraversalCheck()" id="checkBtn" disabled>Check Steps</button>
                </div>
            </div>

        </div>

        <div class="action-button-row">
            <button onclick="startGame()" id="startBtn">Start Task</button>
        </div>

    </div>

    <script>
        // --- Configuration & Constants ---
        const TASK_STEPS = 5;
        const MIN_NODE_VALUE = 10;
        const MAX_NODE_VALUE = 99;
        const MAX_LIST_LENGTH = 8; 

        // --- Data Structure: Node Class ---
        class Node {
            constructor(data) {
                this.data = data;
                this.next = null;
            }
        }

        // --- Data Structure: CircularLinkedList Class (Simplified) ---
        class CircularLinkedList {
            constructor() {
                this.head = null;
                this.tail = null;
                this.size = 0;
            }

            add(data) {
                const newNode = new Node(data);
                if (!this.head) {
                    this.head = newNode;
                    this.tail = newNode;
                    newNode.next = newNode; // Points to itself
                } else {
                    newNode.next = this.head;
                    this.tail.next = newNode;
                    this.tail = newNode;
                }
                this.size++;
            }

            // Optimized insert at the HEAD using the TAIL pointer
            insertAtHead(data) {
                const newNode = new Node(data);
                if (!this.head) {
                    this.head = newNode;
                    this.tail = newNode;
                    newNode.next = newNode;
                } else {
                    newNode.next = this.head;
                    this.tail.next = newNode;
                    this.head = newNode;
                }
                this.size++;
            }

            toArray() {
                if (this.size === 0) return [];
                const arr = [];
                let current = this.head;
                do {
                    arr.push(current.data);
                    current = current.next;
                } while (current !== this.head);
                return arr;
            }

            find(data) {
                if (!this.head) return null;
                let current = this.head;
                do {
                    if (current.data === data) return current;
                    current = current.next;
                } while (current !== this.head);
                return null;
            }
        }

        // --- State Variables ---
        let gameActive = false;
        let stepCounter = 0;
        let currentList = null;
        let currentTask = {}; 
        let nodeClickMode = null; // 'split'

        // --- DOM Elements ---
        const taskDisplay = document.getElementById('taskDisplay');
        const feedbackEl = document.getElementById('feedback');
        const listVisualizationEl = document.getElementById('linkedListVisualization');
        const headPointerLabel = document.getElementById('headPointerLabel');
        const tailPointerLabel = document.getElementById('tailPointerLabel');

        const insertValueInput = document.getElementById('insertValue');
        const insertBtn = document.getElementById('insertBtn');

        const listLengthDisplay = document.getElementById('listLengthDisplay');
        const splitIndexDisplay = document.getElementById('splitIndexDisplay');
        const splitBtn = document.getElementById('splitBtn');
        
        const traversalCountInput = document.getElementById('traversalCount');
        const checkBtn = document.getElementById('checkBtn');


        // --- Utility Functions ---

        function generateRandomUniqueValues(count, min, max, exclude = []) {
            const values = new Set(exclude);
            while (values.size < count + exclude.length) {
                values.add(Math.floor(Math.random() * (max - min + 1)) + min);
            }
            return Array.from(values).filter(v => !exclude.includes(v)).slice(0, count);
        }

        function createRandomList() {
            const list = new CircularLinkedList();
            const initialLength = Math.floor(Math.random() * 3) + 4; // 4 to 6 nodes
            const values = generateRandomUniqueValues(initialLength, MIN_NODE_VALUE, MAX_NODE_VALUE);
            values.sort((a, b) => a - b);
            values.forEach(val => list.add(val));
            return list;
        }

        function generateNewTask() {
            const listArr = currentList.toArray();
            const taskTypes = ['insert', 'split', 'traverse'];
            let taskType = taskTypes[Math.floor(Math.random() * taskTypes.length)];

            if (listArr.length === 0) taskType = 'insert';
            if (listArr.length >= MAX_LIST_LENGTH && taskType === 'insert') taskType = 'split'; 

            if (taskType === 'insert') {
                let newValue;
                do {
                    newValue = Math.floor(Math.random() * (MAX_NODE_VALUE - MIN_NODE_VALUE + 1)) + MIN_NODE_VALUE;
                } while (currentList.find(newValue));
                
                return { type: 'insert', value: newValue };

            } else if (taskType === 'split') {
                const splitIndex = Math.floor(currentList.size / 2);
                
                const targetPrevIndex = splitIndex - 1; 
                const targetNodeValue = listArr[targetPrevIndex];

                return { type: 'split', targetPrevIndex: targetPrevIndex, targetValue: targetNodeValue };

            } else { // Traverse task
                return { type: 'traverse', listSize: currentList.size };
            }
        }

        // --- Visualization Functions ---

        function drawLinkedList() {
            listVisualizationEl.innerHTML = '';
            listVisualizationEl.appendChild(headPointerLabel);
            listVisualizationEl.appendChild(tailPointerLabel);

            if (!currentList || !currentList.head) {
                const emptyMsg = document.createElement('div');
                emptyMsg.style.margin = 'auto';
                emptyMsg.style.fontSize = '1.1em';
                emptyMsg.style.color = '#888';
                emptyMsg.innerText = 'List is empty.';
                listVisualizationEl.appendChild(emptyMsg);
                headPointerLabel.style.display = 'none';
                tailPointerLabel.style.display = 'none';
                return;
            }

            headPointerLabel.style.display = 'block';
            tailPointerLabel.style.display = 'block';

            let current = currentList.head;
            let counter = 0;
            const nodesArr = [];

            do {
                const nodeWrapper = document.createElement('div');
                nodeWrapper.classList.add('node-wrapper');

                if (counter > 0) {
                    const arrowDiv = document.createElement('div');
                    arrowDiv.classList.add('arrow-line');
                    nodeWrapper.appendChild(arrowDiv);
                } 

                const nodeDiv = document.createElement('div');
                nodeDiv.classList.add('cll-node');
                nodeDiv.dataset.value = current.data;
                nodeDiv.dataset.index = counter;
                nodeDiv.onclick = (e) => handleNodeClick(e, current.data, counter);

                if (current === currentList.head) {
                    nodeDiv.classList.add('head-node');
                } 
                
                // Highlight target node for split task (node BEFORE the split)
                if (currentTask.type === 'split' && currentTask.targetValue === current.data) {
                    // Node is highlighted when toggleNodeClickMode is active
                }
                
                const valueSpan = document.createElement('span');
                valueSpan.classList.add('node-data');
                valueSpan.innerText = current.data;
                nodeDiv.appendChild(valueSpan);

                // Add pointer visualization text
                const nextPtrText = document.createElement('span');
                nextPtrText.classList.add('node-pointer-text');
                nextPtrText.innerText = `NEXT: ${current.next === currentList.head ? 'HEAD' : current.next.data}`;
                nodeDiv.appendChild(nextPtrText);

                nodeWrapper.appendChild(nodeDiv);
                listVisualizationEl.appendChild(nodeWrapper);
                nodesArr.push(nodeDiv);
                
                current = current.next;
                counter++;
            } while (current !== currentList.head);
            
            // Draw Circular Link (visually)
            drawCircularLink(nodesArr);
            
            // Adjust pointer positions dynamically
            const firstNodeElement = listVisualizationEl.querySelector('.node-wrapper:first-child .cll-node');
            if (firstNodeElement) {
                 headPointerLabel.style.left = `${firstNodeElement.offsetLeft + 10}px`;
            }
            const lastNodeElement = listVisualizationEl.querySelector('.node-wrapper:last-child .cll-node');
            if (lastNodeElement) {
                 const tailOffset = lastNodeElement.offsetLeft + lastNodeElement.offsetWidth;
                 tailPointerLabel.style.left = `${tailOffset - tailPointerLabel.offsetWidth + 20}px`;
            }
        }

        function drawCircularLink(nodesArr) {
            // Placeholder function: Visually indicates the circular link
            const linkLabel = document.createElement('span');
            linkLabel.style.position = 'absolute';
            linkLabel.style.bottom = '10px';
            linkLabel.style.right = '5px';
            linkLabel.style.color = '#007bff';
            linkLabel.style.fontSize = '0.7em';
            
            listVisualizationEl.appendChild(linkLabel);
        }

        // --- Game Flow ---

        function startGame() {
            gameActive = true;
            stepCounter = 0;
            currentList = createRandomList();
            setControlsEnabled(true);
            nextStep();
            startBtn.disabled = true;
        }

        function nextStep() {
            if (!gameActive) return;

            stepCounter++;
            if (stepCounter > TASK_STEPS) {
                endGame();
                return;
            }

            currentTask = generateNewTask();
            drawLinkedList();
            updateTaskDisplay();
            setFeedback('info', 'Perform the correct Circular Linked List operation using the controls.');
            
            nodeClickMode = null;
        }

        function endGame() {
            gameActive = false;
            setControlsEnabled(false);
            taskDisplay.innerText = `TASK COMPLETE!`;
            setFeedback('success', `You completed ${TASK_STEPS} operations. Click Start Task for a new challenge.`);
            startBtn.disabled = false;
        }

        function updateTaskDisplay() {
            setControlsEnabled(false);

            if (currentTask.type === 'insert') {
                taskDisplay.innerText = `TASK ${stepCounter}/${TASK_STEPS}: OPTIMIZED INSERTION. Insert new node with value ${currentTask.value} at the BEGINNING (HEAD).`;
                
                insertValueInput.value = currentTask.value; 
                insertBtn.disabled = false;

            } else if (currentTask.type === 'split') {
                listLengthDisplay.innerText = currentList.size;
                splitIndexDisplay.innerText = Math.floor(currentList.size / 2) + 1; // Display the index of the node *after* the split
                taskDisplay.innerText = `TASK ${stepCounter}/${TASK_STEPS}: SPLITTING TRAVERSAL. Select the node that would be the TAIL of the first half (Node before the split).`;
                
                splitBtn.disabled = false;

            } else if (currentTask.type === 'traverse') {
                traversalCountInput.value = '';
                listLengthDisplay.innerText = currentList.size;
                taskDisplay.innerText = `TASK ${stepCounter}/${TASK_STEPS}: BOUNDARY CHECK. How many total steps nodes are in the list before returning to HEAD?`;

                // FIX: Enable the Traversal input field and button
                traversalCountInput.disabled = false;
                checkBtn.disabled = false;
            }
        }

        function setControlsEnabled(enabled) {
            const disable = !enabled;
            
            insertValueInput.disabled = disable;
            insertBtn.disabled = disable;
            
            splitBtn.disabled = disable;
            
            // FIX: Use current Task type to determine if input should be disabled
            if (currentTask.type !== 'traverse') {
                traversalCountInput.disabled = disable;
                checkBtn.disabled = disable;
            }
        }
        
        // --- Answer Logic ---

        function handleInsertHeadAttempt() {
            const enteredValue = parseInt(insertValueInput.value);

            if (isNaN(enteredValue) || enteredValue !== currentTask.value) {
                setFeedback('error', 'Incorrect value. You must enter the target value shown in the task.');
                return;
            }

            currentList.insertAtHead(currentTask.value);
            drawLinkedList();
            setFeedback('success', 'Correct! Optimized insertion at HEAD was performed successfully using the TAIL pointer. Advancing to next task...');
            setControlsEnabled(false);
            setTimeout(nextStep, 1500);
        }

        function handleNodeClick(e, clickedData, clickedIndex) {
            if (!gameActive || nodeClickMode !== 'split') return;

            if (currentTask.type === 'split') {
                const targetValue = currentTask.targetValue;

                if (clickedData === targetValue) {
                    e.currentTarget.classList.add('highlight-found'); 
                    setFeedback('success', `Correct! This node would be the new TAIL of the first half after splitting. Advancing...`);
                    
                    setControlsEnabled(false);
                    nodeClickMode = null;
                    setTimeout(nextStep, 1500);

                } else {
                    setFeedback('error', 'Incorrect node selected. Remember, select the node before the split point.');
                    e.currentTarget.classList.add('highlight-target'); 
                    setTimeout(() => e.currentTarget.classList.remove('highlight-target'), 700);
                }
            }
        }
        
        function handleTraversalCheck() {
            const enteredCount = parseInt(traversalCountInput.value);
            const listSize = currentTask.listSize;

            if (isNaN(enteredCount)) {
                 setFeedback('error', 'Please enter a valid number.');
                 return;
            }
            
            if (enteredCount === listSize) {
                 setFeedback('success', `Correct! The list traverses ${listSize} steps before returning to the HEAD pointer.`);
                 setControlsEnabled(false);
                 setTimeout(nextStep, 1500);
            } else {
                 setFeedback('error', `Incorrect. The number of steps to return to HEAD in a CLL is always equal to its size.`);
            }
        }

        function toggleNodeClickMode(mode) {
             nodeClickMode = mode;
             splitBtn.disabled = true;
             setFeedback('info', 'Click the correct node in the visualization now.');
             
             // Highlight the node that is the target value for selection
             const targetNode = listVisualizationEl.querySelector(`[data-value="${currentTask.targetValue}"]`);
             if (targetNode) {
                 targetNode.classList.add('highlight-target');
             }
        }


        function setFeedback(type, message) {
            const feedbackEl = document.getElementById('feedback');
            feedbackEl.className = '';
            feedbackEl.classList.add(`feedback-${type}`);
            feedbackEl.innerText = message;
        }

        // --- Initial Setup ---
        window.onload = function() {
            setControlsEnabled(false);
            setFeedback('info', 'Click "Start Task" to begin your Circular Linked List challenge!');
            currentList = createRandomList(); 
            drawLinkedList(); 
        };

        window.addEventListener('resize', () => {
            drawLinkedList(); 
        });
    </script>
</body>
</html>