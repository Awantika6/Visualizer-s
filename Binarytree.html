<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Tree Structure </title>
    <style>
        /* --- General Styling --- */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f4f7f6;
            color: #333;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1);
            width: 95%;
            max-width: 900px;
        }

        h1, h2 {
            color: #007bff;
            text-align: center;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 10px;
            margin-top: 0;
        }

        /* --- Task & Feedback --- */
        #taskDisplay {
            font-size: 1.1em; /* Adjusted Font Size */
            font-weight: bold;
            padding: 15px;
            border-radius: 8px;
            background-color: #d1ecf1;
            color: #0c5460;
            text-align: center;
            margin-bottom: 20px;
            border: 1px solid #bee5eb;
        }

        #feedback {
            min-height: 40px;
            padding: 10px;
            margin-top: 15px;
            border-radius: 8px;
            text-align: center;
            font-weight: 500;
            font-size: 1.1em;
            transition: all 0.3s ease;
        }
        
        .feedback-success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .feedback-error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 25px;
        }

        button {
            padding: 10px 20px;
            border-radius: 8px;
            border: none;
            font-size: 16px;
            cursor: pointer;
            background-color: #28a745;
            color: white;
            transition: background-color 0.3s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        button:hover:not(:disabled) { background-color: #1e8736; }
        button:disabled { background-color: #cccccc; cursor: not-allowed; }

        /* --- Tree Visualization Layout --- */
        #treeVisualization {
            position: relative;
            height: 350px;
            width: 100%;
            margin: 0 auto;
            border: 1px solid #ccc;
            border-radius: 10px;
            background-color: #fcfcfc;
        }

        .node-container {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px; 
            height: 40px;
            border-radius: 50%;
            transition: all 0.2s ease;
            background-color: #007bff;
            color: white;
            font-weight: bold;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            border: 3px solid transparent;
            cursor: pointer;
            z-index: 10;
        }
        
        .node-container:hover { border-color: #ffc107; }

        .node-clicked-correct { background-color: #28a745 !important; border-color: #1e7e34 !important; }
        .node-clicked-wrong { background-color: #dc3545 !important; border-color: #a71d2a !important; }
        
        /* Specific task buttons (for Traversal/Identification) */
        #traversalOptions button {
            background-color: #6f42c1; /* Purple */
        }
        #traversalOptions button:hover {
            background-color: #5f35a0;
        }
        
        /* Explanation Box */
        .explanation-box {
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 8px;
            background-color: #fff3cd; /* Warning Yellow */
            color: #856404;
            border: 1px solid #ffeeba;
        }
        
        /* Canvas for Edges */
        #edgeCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 5;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🌲 Binary Tree </h1>
        
        <div class="explanation-box">
            <p><strong>Binary Tree Rule:</strong> Max 2 children per node (Left/Right).</p>
            <h5> Subtype Rules (Check the definitions below)</h5>
            <ul style="font-size: 0.9em;"> <li>Full: Every internal node has two children.</li>
                <li>Complete: Filled level-by-level, left-to-right.</li>
                <li>Perfect: Both Full and Complete (all leaves at the same depth).</li>
                <li>Skewed: Nodes are only on one side (Left or Right).</li>
            </ul>
        </div>
        
        <div id="taskDisplay">Click 'Start Task' to begin!</div>

        <div id="treeVisualization">
            <canvas id="edgeCanvas"></canvas>
            
        </div>

        <div id="feedback" class="feedback-info">Instructions: The task will change with each step. Read the instructions carefully.</div>

        <div id="traversalOptions" class="controls" style="display:none;">
            <button onclick="handleTraversalAnswer('FULL')">Full Binary Tree</button>
            <button onclick="handleTraversalAnswer('COMPLETE')">Complete Binary Tree</button>
            <button onclick="handleTraversalAnswer('PERFECT')">Perfect Binary Tree</button>
            <button onclick="handleTraversalAnswer('SKEWED')">Skewed Binary Tree</button>
        </div>
        
        <div id="mainControls" class="controls">
            <button onclick="startGame()">Start Task</button>
            <button onclick="nextQuestion()" disabled style="background-color:#007bff;">Next Task</button>
        </div>

    </div>

    <script>
        // --- Configuration & Constants ---
        const NODE_RADIUS = 20;
        const TOTAL_TASKS = 5; 
        
        // --- State Variable for Remapped Buttons in Task 3 & 5 ---
        let currentTaskOptions = {};
        
        // --- Sample Tree Structures (ID: 1-7, A-G) ---
        // P=Perfect, C=Complete, F=Full, S=Skewed, E=Error, L=Left Skewed
        const TREE_SETS = [
            // Task 1: Perfect Binary Tree (ID: 1-7)
            { 
                id: 'PERFECT_SET', type: 'PERFECT', nodes: [
                    { id: 1, data: 50, x: 350, y: 50, parentId: null },
                    { id: 2, data: 25, x: 200, y: 150, parentId: 1 },
                    { id: 3, data: 75, x: 500, y: 150, parentId: 1 },
                    { id: 4, data: 12, x: 125, y: 250, parentId: 2 },
                    { id: 5, data: 37, x: 275, y: 250, parentId: 2 },
                    { id: 6, data: 62, x: 425, y: 250, parentId: 3 },
                    { id: 7, data: 87, x: 575, y: 250, parentId: 3 }
                ]
            },
            // Task 2: Full Violation (Node 3 is internal but has only one child)
            { 
                id: 'FULL_ERROR_SET', type: 'FULL_ERROR', nodes: [
                    { id: 1, data: 50, x: 350, y: 50, parentId: null },
                    { id: 2, data: 25, x: 200, y: 150, parentId: 1 },
                    { id: 3, data: 75, x: 500, y: 150, parentId: 1 },
                    { id: 4, data: 12, x: 125, y: 250, parentId: 2 },
                    { id: 5, data: 37, x: 275, y: 250, parentId: 2 },
                    { id: 6, data: 62, x: 425, y: 250, parentId: 3 }
                ],
                violationId: 3 
            },
            // Task 3: Right Skewed (R_SKEWED) - Adjusted size
            {
                id: 'R_SKEWED_SET', type: 'RIGHT_SKEWED', nodes: [
                    { id: 1, data: 10, x: 150, y: 40, parentId: null }, 
                    { id: 2, data: 20, x: 250, y: 130, parentId: 1 }, 
                    { id: 3, data: 30, x: 350, y: 220, parentId: 2 }, 
                    { id: 4, data: 40, x: 450, y: 310, parentId: 3 }  
                ]
            },
            // Task 4: Complete but not Full/Perfect (T4_COMPLETE)
            {
                id: 'T4_COMPLETE_SET', type: 'COMPLETE', nodes: [
                    { id: 1, data: 100, x: 350, y: 50, parentId: null },
                    { id: 2, data: 50, x: 250, y: 150, parentId: 1 },
                    { id: 3, data: 150, x: 450, y: 150, parentId: 1 },
                    { id: 4, data: 25, x: 150, y: 250, parentId: 2 } // Missing right child of 2 and children of 3
                ]
            },
            // Task 5: Left Skewed (L_SKEWED) - Adjusted size
            {
                id: 'L_SKEWED_SET', type: 'LEFT_SKEWED', nodes: [
                    { id: 1, data: 50, x: 450, y: 40, parentId: null }, 
                    { id: 2, data: 40, x: 350, y: 130, parentId: 1 }, 
                    { id: 3, data: 30, x: 250, y: 220, parentId: 2 }, 
                    { id: 4, data: 20, x: 150, y: 310, parentId: 3 }  
                ]
            }
        ];
        
        // --- DOM Elements & State ---
        const visualizationEl = document.getElementById('treeVisualization');
        const taskDisplay = document.getElementById('taskDisplay');
        const feedbackEl = document.getElementById('feedback');
        const nextButton = document.querySelector('#mainControls button:last-child');
        const traversalOptions = document.getElementById('traversalOptions');

        let nodes = {}; 
        let currentTask = 0;
        let gameActive = false;
        let currentTreeSet = null;

        const canvas = document.getElementById('edgeCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = visualizationEl.clientWidth;
        canvas.height = visualizationEl.clientHeight;

        // --- Core Functions ---

        function setupNodes(treeData) {
            visualizationEl.innerHTML = '<canvas id="edgeCanvas"></canvas>'; 
            const newCanvas = document.getElementById('edgeCanvas');
            const newCtx = newCanvas.getContext('2d');
            
            newCanvas.width = visualizationEl.clientWidth;
            newCanvas.height = visualizationEl.clientHeight;
            nodes = {};
            
            treeData.forEach(data => {
                const nodeElement = document.createElement('div');
                nodeElement.classList.add('node-container');
                nodeElement.innerText = data.data;
                nodeElement.dataset.id = data.id;

                nodeElement.style.left = `${data.x - NODE_RADIUS}px`;
                nodeElement.style.top = `${data.y - NODE_RADIUS}px`;
                
                // Only make nodes clickable if the task requires node interaction
                nodeElement.addEventListener('click', () => handleNodeClick(data.id));
                visualizationEl.appendChild(nodeElement);

                nodes[data.id] = { ...data, element: nodeElement };
            });
            
            drawEdges(newCtx, treeData);
        }
        
        function drawEdges(context, treeData) {
            context.clearRect(0, 0, canvas.width, canvas.height);
            context.strokeStyle = '#999999';
            context.lineWidth = 2;

            treeData.forEach(nodeData => {
                const node = nodeData;
                if (node.parentId) {
                    const parent = nodes[node.parentId];
                    context.beginPath();
                    // Start point: Parent center
                    context.moveTo(parent.x, parent.y + NODE_RADIUS);
                    // End point: Child center
                    context.lineTo(node.x, node.y - NODE_RADIUS);
                    context.stroke();
                }
            });
        }

        function startGame() {
            gameActive = true;
            currentTask = 0;
            nextQuestion();
            document.getElementById('mainControls').style.display = 'flex';
        }
        
        function clearFeedback() {
             // Function to clear the feedback area
             feedbackEl.className = 'feedback-info';
             feedbackEl.innerHTML = ''; 
        }


        function nextQuestion() {
            currentTask++;
            if (currentTask > TOTAL_TASKS) {
                endGame();
                return;
            }
            
            // --- FIX: Clear the previous feedback message here ---
            clearFeedback();

            // Reset options state
            currentTaskOptions = {};

            // Hide/Show controls based on task type
            traversalOptions.style.display = 'none';
            nextButton.disabled = true;
            clearHighlights();
            
            const taskIndex = currentTask - 1;
            currentTreeSet = TREE_SETS[taskIndex];
            setupNodes(currentTreeSet.nodes);
            
            // Set up the specific task
            switch (currentTask) {
                case 1:
                    taskDisplay.innerHTML = `TASK 1: CLASSIFICATION. Identify the exact subtype of the tree shown.`;
                    setFeedback('info', 'Choose one of the buttons below. ');
                    traversalOptions.style.display = 'flex';
                    // Reset options for standard classification
                    document.querySelector('#traversalOptions button:nth-child(1)').textContent = "Full Binary Tree";
                    document.querySelector('#traversalOptions button:nth-child(2)').textContent = "Complete Binary Tree";
                    document.querySelector('#traversalOptions button:nth-child(3)').textContent = "Perfect Binary Tree";
                    document.querySelector('#traversalOptions button:nth-child(4)').textContent = "Skewed Binary Tree";
                    document.querySelector('#traversalOptions button:nth-child(3)').style.display = 'inline-block';
                    document.querySelector('#traversalOptions button:nth-child(4)').style.display = 'inline-block';
                    break;
                case 2:
                    taskDisplay.innerHTML = `TASK 2: PROPERTY VIOLATION. This tree attempts to be a Full Binary Tree. Click the node that violates this property (i.e., has only one child).`;
                    
                    break;
                case 3:
                    taskDisplay.innerHTML = `TASK 3: SKEWNESS. Is this tree Left Skewed or Right Skewed? Click the correct button below.`;
                    
                    traversalOptions.style.display = 'flex';
                    
                    // Reconfigure traversal options for SKEW check 
                    document.querySelector('#traversalOptions button:nth-child(1)').textContent = "Left Skewed"; // Original value: FULL
                    document.querySelector('#traversalOptions button:nth-child(2)').textContent = "Right Skewed"; // Original value: COMPLETE
                    document.querySelector('#traversalOptions button:nth-child(3)').style.display = 'none';
                    document.querySelector('#traversalOptions button:nth-child(4)').style.display = 'none';
                    
                    // Store the temporary mapping for correct answer check:
                    currentTaskOptions = {
                        'FULL': 'LEFT_SKEWED',
                        'COMPLETE': 'RIGHT_SKEWED'
                    };
                    break;
                case 4:
                    taskDisplay.innerHTML = `TASK 4: CLASSIFICATION. Identify the exact subtype of the tree shown.`;
                    
                    traversalOptions.style.display = 'flex';
                    // Reset options for standard classification
                    document.querySelector('#traversalOptions button:nth-child(1)').textContent = "Full Binary Tree";
                    document.querySelector('#traversalOptions button:nth-child(2)').textContent = "Complete Binary Tree";
                    document.querySelector('#traversalOptions button:nth-child(3)').textContent = "Perfect Binary Tree";
                    document.querySelector('#traversalOptions button:nth-child(4)').textContent = "Skewed Binary Tree";
                    document.querySelector('#traversalOptions button:nth-child(3)').style.display = 'inline-block';
                    document.querySelector('#traversalOptions button:nth-child(4)').style.display = 'inline-block';
                    break;
                case 5:
                    taskDisplay.innerHTML = `TASK 5: SKEWNESS. Is this tree Left Skewed or Right Skewed? Click the correct button below.`;
                    
                    traversalOptions.style.display = 'flex';
                    
                    // Reconfigure traversal options for SKEW check (Task 5)
                    document.querySelector('#traversalOptions button:nth-child(1)').textContent = "Left Skewed"; // Original value: FULL
                    document.querySelector('#traversalOptions button:nth-child(2)').textContent = "Right Skewed"; // Original value: COMPLETE
                    document.querySelector('#traversalOptions button:nth-child(3)').style.display = 'none';
                    document.querySelector('#traversalOptions button:nth-child(4)').style.display = 'none';
                    
                    // Store the temporary mapping for correct answer check:
                    currentTaskOptions = {
                        'FULL': 'LEFT_SKEWED',
                        'COMPLETE': 'RIGHT_SKEWED'
                    };
                    break;
                default:
                    endGame();
            }
        }
        
        function endGame() {
            gameActive = false;
            taskDisplay.innerHTML = `ASSESSMENT COMPLETE! 🎉`;
            setFeedback('success', 'You have finished all tasks. Click Start Assessment to try again!');
            nextButton.disabled = true;
        }

        // --- Answer Handlers ---

        function handleNodeClick(clickedId) {
            // Task 2 is the only node-click task currently. It requires a manual "Next Task" click.
            if (!gameActive || nextButton.disabled === false) return; 

            if (currentTask === 2) {
                // Task 2: Property Violation
                if (clickedId === currentTreeSet.violationId) {
                    processCorrectAnswer(clickedId, '✅ Correct! Node 75 (3) violates the Full property because it only has one child (6), not two.');
                    
                } else {
                    processIncorrectAnswer(clickedId, '❌ Incorrect. That node adheres to the Full property. Try another internal node.');
                }
            }
        }

        function handleTraversalAnswer(answer) {
             // Tasks 1, 3, 4, 5 use buttons and auto-advance.
             if (!gameActive) return;

             let isCorrect = false;
             let feedbackMessage = '';
             let correctType = currentTreeSet.type;
             
             // Check if we are in a SKEW task (Task 3 or 5) where button values are remapped.
             let actualAnswer = answer;
             if (currentTask === 3 || currentTask === 5) {
                 actualAnswer = currentTaskOptions[answer];
             }

             if (currentTask === 1) {
                 // Task 1: PERFECT_SET
                 isCorrect = (actualAnswer === correctType);
                 feedbackMessage = isCorrect 
                    ? `✅ Correct! This is a ${correctType} Binary Tree because every level is full and all leaves are at the same depth.`
                    : `❌ Incorrect. The correct answer is ${correctType}. Review the definitions.`;
                 
             } else if (currentTask === 3) {
                 // Task 3: RIGHT_SKEWED
                 isCorrect = (actualAnswer === correctType); 
                 
                 feedbackMessage = isCorrect 
                    ? `✅ Correct! This is Right Skewed because nodes are predominantly found only on the right sub-tree, resembling a linked list.`
                    : `❌ Incorrect. This tree is Right Skewed. Review the direction of the bias.`;

             } else if (currentTask === 4) {
                 // Task 4: COMPLETE (not Full/Perfect)
                 isCorrect = (actualAnswer === correctType); 
                 
                 feedbackMessage = isCorrect 
                    ? `✅ Correct! This is Complete because levels are filled left-to-right, but it's not Full or Perfect.`
                    : `❌ Incorrect. The correct answer is ${correctType}. Review the definitions.`;

             } else if (currentTask === 5) {
                 // Task 5: LEFT_SKEWED
                 isCorrect = (actualAnswer === correctType); 
                 
                 feedbackMessage = isCorrect 
                    ? `✅ Correct! This is Left Skewed because nodes are predominantly found only on the left sub-tree.`
                    : `❌ Incorrect. This tree is Left Skewed. Review the direction of the bias.`;
             }
             
             if (isCorrect) {
                 setFeedback('success', feedbackMessage);
                 
                 // Auto-advance for button clicks
                 traversalOptions.style.display = 'none';
                 setTimeout(() => {
                     nextQuestion(); 
                 }, 1500); // 1.5 second delay
                 
             } else {
                 setFeedback('error', feedbackMessage);
             }
        }
        
        function processCorrectAnswer(clickedId, message) {
            highlightNode(clickedId, true);
            setFeedback('success', message);
            nextButton.disabled = false; // Enable manual "Next Task" click for node tasks
        }

        function processIncorrectAnswer(clickedId, message) {
            highlightNode(clickedId, false);
            setFeedback('error', message);
        }

        // --- Visual Helpers ---
        function highlightNode(nodeId, isCorrect) {
            const el = nodes[nodeId].element;
            el.classList.remove('node-clicked-correct', 'node-clicked-wrong'); 
            
            if (isCorrect) {
                el.classList.add('node-clicked-correct');
            } else {
                el.classList.add('node-clicked-wrong');
                setTimeout(() => {
                    el.classList.remove('node-clicked-wrong');
                }, 700);
            }
        }

        function clearHighlights() {
            Object.values(nodes).forEach(node => {
                node.element.classList.remove('node-clicked-correct', 'node-clicked-wrong');
                node.element.style.borderColor = 'transparent'; 
            });
        }
        
        function setFeedback(type, message) {
            feedbackEl.className = '';
            feedbackEl.classList.add(`feedback-${type}`);
            feedbackEl.innerHTML = message;
        }

        // --- Event Listeners ---
        window.addEventListener('resize', () => {
            // Re-render the tree on resize to maintain layout integrity
            if (currentTreeSet) {
                setupNodes(currentTreeSet.nodes);
            }
        });
        
        // Initial setup
        // Set initial canvas size
        window.addEventListener('load', () => {
            const initialCanvas = document.getElementById('edgeCanvas');
            initialCanvas.width = visualizationEl.clientWidth;
            initialCanvas.height = visualizationEl.clientHeight;
        });
    </script>
</body>
</html>